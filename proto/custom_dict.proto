// Copyright 2019-present BAIKAL AI Inc.
//

syntax = "proto3";

package bareun;

option go_package = "bareun.ai/lang/bareun/genproto/bareun;svc";
option java_package = "ai.bareun.protos";
option java_multiple_files = true;
option java_outer_classname = "CustomDictionaryServiceProto";

import "dict_common.proto";
import "google/protobuf/empty.proto";

service CustomDictionaryService {
  // 전체 목록을 다 가져오기
  rpc GetCustomDictionaryList (google.protobuf.Empty) returns (GetCustomDictionaryListResponse) {}
  // 현재 저장되어 있는 사전 하나만 가져온다.
  rpc GetCustomDictionary (GetCustomDictionaryRequest) returns (GetCustomDictionaryResponse) {}

  // 전체를 모두 다 바꿔치기하는 경우
  rpc UpdateCustomDictionary (UpdateCustomDictionaryRequest) returns (UpdateCustomDictionaryResponse) {}

  // 여러 개를 한꺼번에 지운다.
  rpc RemoveCustomDictionaries (RemoveCustomDictionariesRequest) returns (RemoveCustomDictionariesResponse) {}

  // 사용사 사전 사이의 충돌을 점검한다.
  rpc CheckConflict (CheckConflictRequest) returns (CheckConflictResponse) {}
}

// 하나의 도메인용 커스텀 사전 데이터
//
message CustomDictionaryMeta {
  string domain_name = 1;

  message DictMeta {
    // 사전의 유형
    DictType type = 1;
    // 사전의 이름
    // 사전의 이름은 반드시 "[DomainName]-"로 시작해야 한다.
    // 사전의 이름은 다음 규칙에 따라서 만든다.
    // 고유명사는 np-set
    // 복합명사는 cp-set
    // 복합명사분리사전은 `cp-caret-set`
    string name = 2;
    // 사전 데이터의 개수
    int32 items_count = 3;
  }

  // 고유명사용 사전
  DictMeta np_set = 2;
  // 복합명사용 사전
  DictMeta cp_set = 3;
  // 복합명사 분리용 사전
  DictMeta cp_caret_set = 4;
  // 동사 사전
  DictMeta vv_set = 5;
  // 형용사 사전
  DictMeta va_set = 6;
}

// 커스텀 사전의 데이터 전송 규격
message CustomDictionary {
  string domain_name = 1;
  // 고유명사용 사전
  DictSet np_set = 2;
  // 복합명사용 사전
  DictSet cp_set = 3;
  // 복합명사 분리용 사전
  DictSet cp_caret_set = 4;
  // 동사 사전
  DictSet vv_set = 5;
  // 형용사 사전
  DictSet va_set = 6;
  // 관형사 사전
  DictSet mm_set = 7;
  // 부사 사전
  DictSet mag_set = 8;
  // 감탄사 사전
  DictSet ic_set = 9;
}

//
// 프로세스 내부에서 서비스 중인 도메인 Dictionary 사전
//
message CustomDictionaryMap {
  map<string, CustomDictionary> custom_dict_map = 1;
}

// 커스텀 사전 목록을 가져온다.
message GetCustomDictionaryListResponse {
  repeated CustomDictionaryMeta domain_dicts = 1;
}

message GetCustomDictionaryRequest {
  string domain_name = 1;
}

message GetCustomDictionaryResponse {
  string domain_name = 1;
  CustomDictionary dict = 2;
}

message UpdateCustomDictionaryRequest {
  string domain_name = 1;
  CustomDictionary dict = 2;
}

message UpdateCustomDictionaryResponse {
  string updated_domain_name = 1;
}

message RemoveCustomDictionariesRequest {
  repeated string domain_names = 1;
  bool all = 2;
}

// 삭제된 커스텀 사전의 목록
message RemoveCustomDictionariesResponse {
  map<string, bool> deleted_domain_names = 1;
}


// 사용자 사전의 충돌을 점검하기 위한 요청
message CheckConflictRequest {
  // 비교할 사전들의 목록
  // 사전의 내부에서도 비교를 할 수 있기 때문에 하나로도 충분하다.
  repeated string domain_names = 1;
}

// 사용자 사전의 충돌 점검 응답
message CheckConflictResponse {
  // 전체 충돌의 내욤
  repeated Conflict conflicts = 1;
}

// 비교대상 사전 기본 정보
message DictOne {
  // 도메인 이름
  string dict_name = 1;
  // 사전의 이름 (np_set 등)
  string dict_set_name = 2;
}

// 하나의 충돌에 대한 설정
message Conflict {
  // 비교의 왼쪽
  DictOne  left  = 1;
  // 비교의 오른쪽
  DictOne  right = 2;
  // 단어 왼쪽
  string left_word = 3;
  // 단어 오른쪽
  string right_word = 4;
  // 충돌인가?
  bool conflict = 5;
  // 중복인가?
  bool duplicated = 6;

  // 오류 메시지
  string conflict_msg = 11;
}
